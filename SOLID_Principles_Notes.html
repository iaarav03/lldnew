<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOLID Principles in C++ - Complete Beginner Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            font-size: 16px;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #0056b3;
        }
        h1 {
            border-bottom: 3px solid #0056b3;
            padding-bottom: 15px;
            font-size: 2.2em;
        }
        h2 {
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
            margin-top: 30px;
            font-size: 1.5em;
        }
        h3 {
            color: #007bff;
            font-size: 1.2em;
        }
        p {
            margin-bottom: 15px;
        }
        pre {
            background: #f8f9fa;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 14px;
            border: 1px solid #e9ecef;
        }
        pre code {
            background: transparent;
            color: #333;
            padding: 0;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            color: #333;
        }
        ul, ol {
            padding-left: 25px;
        }
        li {
            margin-bottom: 12px;
        }
        strong {
            color: #d73a49;
            font-weight: 600;
        }
        .example {
            border-left: 4px solid #007bff;
            padding: 20px;
            margin: 20px 0;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .simple-explanation {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }
        .bad-example {
            background-color: #ffebee;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
        }
        .good-example {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }
        .interview-tip {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
        .navigation {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
        }
        .navigation a {
            color: #0056b3;
            text-decoration: none;
            margin: 0 10px;
            padding: 5px 10px;
            border-radius: 3px;
            background-color: #fff;
        }
        .navigation a:hover {
            background-color: #0056b3;
            color: #fff;
        }
        .principle-header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .principle-header h3 {
            color: #ffffff !important;
            margin: 0;
        }
        .principle-summary {
            background-color: #f0f4ff;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #6c5ce7;
        }
        footer {
            margin-top: 40px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="navigation">
            <a href="index.html">Home</a>
            <a href="Design_Patterns_Index.html">Design Patterns</a>
            <a href="#srp">SRP</a>
            <a href="#ocp">OCP</a>
            <a href="#lsp">LSP</a>
            <a href="#isp">ISP</a>
            <a href="#dip">DIP</a>
        </div>

        <h1>üéØ SOLID Principles in C++ - Complete Beginner Guide</h1>

        <div class="simple-explanation">
            <h3>üìö What are SOLID Principles?</h3>
            <p><strong>SOLID</strong> is an acronym for five design principles that make software designs more understandable, flexible, and maintainable. These principles help you write better object-oriented code that is easier to test, maintain, and extend.</p>
            
            <p><strong>S</strong> - Single Responsibility Principle</p>
            <p><strong>O</strong> - Open/Closed Principle</p>
            <p><strong>L</strong> - Liskov Substitution Principle</p>
            <p><strong>I</strong> - Interface Segregation Principle</p>
            <p><strong>D</strong> - Dependency Inversion Principle</p>
        </div>

        <div class="interview-tip">
            <h3>üí° Why Learn SOLID Principles?</h3>
            <ul>
                <li><strong>Maintainable Code:</strong> Easier to modify and extend without breaking existing functionality</li>
                <li><strong>Testable Code:</strong> Classes with single responsibilities are easier to test</li>
                <li><strong>Flexible Architecture:</strong> Changes in one part don't ripple through the entire system</li>
                <li><strong>Interview Success:</strong> SOLID principles are frequently asked in technical interviews</li>
                <li><strong>Team Collaboration:</strong> Code follows predictable patterns that team members can understand</li>
            </ul>
        </div>

        <!-- Single Responsibility Principle -->
        <h2 id="srp">1. üìù Single Responsibility Principle (SRP)</h2>
        
        <div class="principle-header">
            <h3>"A class should have only one reason to change"</h3>
        </div>

        <div class="simple-explanation">
            <h3>ü§î What does this mean?</h3>
            <p>Think of it like this: A person shouldn't be both a <strong>chef</strong> and a <strong>cashier</strong> at the same time. Each should focus on their specific job. Similarly, a class should have only <strong>one responsibility</strong> or <strong>one job to do</strong>.</p>
            
            <p><strong>Simple Rule:</strong> If you can describe a class with "AND", it's probably doing too much!</p>
        </div>

        <div class="bad-example">
            <h3>‚ùå Bad Example - Violating SRP</h3>
            <pre><code>// This class does TOO MUCH! (User management AND email sending AND file operations)
class User {
private:
    string name, email;
    
public:
    // User data management
    void setName(const string& n) { name = n; }
    void setEmail(const string& e) { email = e; }
    string getName() const { return name; }
    string getEmail() const { return email; }
    
    // Email functionality (NOT user's responsibility!)
    void sendWelcomeEmail() {
        cout << "Sending welcome email to " << email << endl;
        // Complex email sending logic here...
        cout << "Email sent!" << endl;
    }
    
    // File operations (ALSO not user's responsibility!)
    void saveToFile() {
        ofstream file("users.txt");
        file << name << "," << email << endl;
        file.close();
        cout << "User saved to file" << endl;
    }
};

// Problems with this approach:
// 1. If email service changes, we need to modify User class
// 2. If file format changes, we need to modify User class  
// 3. Hard to test individual functionalities
// 4. Class becomes bloated and hard to maintain</code></pre>
        </div>

        <div class="good-example">
            <h3>‚úÖ Good Example - Following SRP</h3>
            <pre><code>// Each class has ONE responsibility

// 1. User class - Only manages user data
class User {
private:
    string name, email;
    
public:
    void setName(const string& n) { name = n; }
    void setEmail(const string& e) { email = e; }
    string getName() const { return name; }
    string getEmail() const { return email; }
};

// 2. EmailService class - Only handles email operations  
class EmailService {
public:
    void sendWelcomeEmail(const User& user) {
        cout << "Sending welcome email to " << user.getEmail() << endl;
        // Email sending logic here...
        cout << "Email sent!" << endl;
    }
    
    void sendPasswordReset(const User& user) {
        cout << "Sending password reset to " << user.getEmail() << endl;
    }
};

// 3. FileManager class - Only handles file operations
class FileManager {
public:
    void saveUser(const User& user) {
        ofstream file("users.txt", ios::app);
        file << user.getName() << "," << user.getEmail() << endl;
        file.close();
        cout << "User saved to file" << endl;
    }
    
    void loadUser(User& user, const string& filename) {
        // File loading logic here...
    }
};

// Usage example
int main() {
    User user;
    user.setName("John Doe");
    user.setEmail("john@example.com");
    
    EmailService emailService;
    emailService.sendWelcomeEmail(user);
    
    FileManager fileManager;
    fileManager.saveUser(user);
    
    return 0;
}</code></pre>
        </div>

        <div class="principle-summary">
            <h3>üìã SRP Benefits:</h3>
            <ul>
                <li><strong>Easy Testing:</strong> Each class can be tested independently</li>
                <li><strong>Easy Maintenance:</strong> Changes in email logic won't affect User class</li>
                <li><strong>Reusability:</strong> EmailService can be used for different entities</li>
                <li><strong>Clear Code:</strong> Each class has a clear, single purpose</li>
            </ul>
        </div>

        <!-- Open/Closed Principle -->
        <h2 id="ocp">2. üîì Open/Closed Principle (OCP)</h2>
        
        <div class="principle-header">
            <h3>"Software entities should be open for extension, but closed for modification"</h3>
        </div>

        <div class="simple-explanation">
            <h3>ü§î What does this mean?</h3>
            <p>Think of it like a <strong>smartphone</strong>: You can extend its functionality by installing apps (open for extension), but you don't modify the phone's core operating system (closed for modification).</p>
            
            <p><strong>Simple Rule:</strong> You should be able to add new features without changing existing code!</p>
        </div>

        <div class="bad-example">
            <h3>‚ùå Bad Example - Violating OCP</h3>
            <pre><code>// This approach requires modifying existing code for new shapes
class AreaCalculator {
public:
    double calculateArea(const string& shapeType, double param1, double param2 = 0) {
        if (shapeType == "rectangle") {
            return param1 * param2;
        }
        else if (shapeType == "circle") {
            return 3.14159 * param1 * param1;
        }
        // Problem: To add triangle, we need to MODIFY this function
        else if (shapeType == "triangle") {  // New addition requires modification!
            return 0.5 * param1 * param2;
        }
        return 0;
    }
};

// Problems:
// 1. Every new shape requires modifying AreaCalculator
// 2. Risk of breaking existing functionality  
// 3. Violates OCP - not closed for modification</code></pre>
        </div>

        <div class="good-example">
            <h3>‚úÖ Good Example - Following OCP</h3>
            <pre><code>// Base class that defines the contract
class Shape {
public:
    virtual double calculateArea() const = 0;
    virtual ~Shape() = default;
};

// Existing shapes - these are CLOSED for modification
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    double calculateArea() const override {
        return width * height;
    }
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    
    double calculateArea() const override {
        return 3.14159 * radius * radius;
    }
};

// New shape - EXTENDS without modifying existing code!
class Triangle : public Shape {
private:
    double base, height;
    
public:
    Triangle(double b, double h) : base(b), height(h) {}
    
    double calculateArea() const override {
        return 0.5 * base * height;
    }
};

// Calculator doesn't need modification for new shapes!
class AreaCalculator {
public:
    double calculateTotalArea(const vector<unique_ptr<Shape>>& shapes) {
        double total = 0;
        for (const auto& shape : shapes) {
            total += shape->calculateArea();
        }
        return total;
    }
};

// Usage example
int main() {
    vector<unique_ptr<Shape>> shapes;
    shapes.push_back(make_unique<Rectangle>(5, 10));
    shapes.push_back(make_unique<Circle>(7));
    shapes.push_back(make_unique<Triangle>(6, 8));  // New shape added without modification!
    
    AreaCalculator calculator;
    cout << "Total area: " << calculator.calculateTotalArea(shapes) << endl;
    
    return 0;
}</code></pre>
        </div>

        <div class="principle-summary">
            <h3>üìã OCP Benefits:</h3>
            <ul>
                <li><strong>Safer Updates:</strong> Adding features doesn't risk breaking existing code</li>
                <li><strong>Easier Maintenance:</strong> New requirements don't require touching old code</li>
                <li><strong>Better Testing:</strong> Existing functionality remains unchanged and tested</li>
                <li><strong>Team Productivity:</strong> Multiple developers can work on extensions simultaneously</li>
            </ul>
        </div>

        <!-- Liskov Substitution Principle -->
        <h2 id="lsp">3. üîÑ Liskov Substitution Principle (LSP)</h2>
        
        <div class="principle-header">
            <h3>"Objects of a superclass should be replaceable with objects of a subclass without breaking functionality"</h3>
        </div>

        <div class="simple-explanation">
            <h3>ü§î What does this mean?</h3>
            <p>Think of it like <strong>different types of birds</strong>: If your code works with a "Bird" object, it should work with any specific type of bird (like Robin, Eagle, etc.) without any problems.</p>
            
            <p><strong>Simple Rule:</strong> A child class should be able to replace its parent class without breaking anything!</p>
        </div>

        <div class="bad-example">
            <h3>‚ùå Bad Example - Violating LSP</h3>
            <pre><code>// This violates LSP because not all birds can fly!
class Bird {
public:
    virtual void fly() {
        cout << "Bird is flying!" << endl;
    }
};

class Duck : public Bird {
public:
    void fly() override {
        cout << "Duck is flying!" << endl;
    }
};

class Penguin : public Bird {
public:
    void fly() override {
        // Penguins can't fly! This breaks the expected behavior
        throw runtime_error("Penguins can't fly!");
    }
};

// This function expects ALL birds to fly
void makeBirdFly(Bird& bird) {
    bird.fly();  // This will crash for Penguin!
}

int main() {
    Duck duck;
    Penguin penguin;
    
    makeBirdFly(duck);     // Works fine
    makeBirdFly(penguin);  // CRASHES! Violates LSP
    
    return 0;
}</code></pre>
        </div>

        <div class="good-example">
            <h3>‚úÖ Good Example - Following LSP</h3>
            <pre><code>// Better design that follows LSP
class Bird {
protected:
    string name;
    
public:
    Bird(const string& n) : name(n) {}
    
    virtual void eat() {
        cout << name << " is eating." << endl;
    }
    
    virtual void makeSound() {
        cout << name << " makes a sound." << endl;
    }
    
    virtual ~Bird() = default;
};

// Separate interface for flying behavior
class Flyable {
public:
    virtual void fly() = 0;
    virtual ~Flyable() = default;
};

// Flying birds implement both Bird and Flyable
class Duck : public Bird, public Flyable {
public:
    Duck() : Bird("Duck") {}
    
    void makeSound() override {
        cout << "Duck says: Quack!" << endl;
    }
    
    void fly() override {
        cout << "Duck is flying gracefully!" << endl;
    }
};

class Eagle : public Bird, public Flyable {
public:
    Eagle() : Bird("Eagle") {}
    
    void makeSound() override {
        cout << "Eagle says: Screech!" << endl;
    }
    
    void fly() override {
        cout << "Eagle is soaring high!" << endl;
    }
};

// Non-flying birds only implement Bird
class Penguin : public Bird {
public:
    Penguin() : Bird("Penguin") {}
    
    void makeSound() override {
        cout << "Penguin says: Honk!" << endl;
    }
    
    void swim() {
        cout << "Penguin is swimming!" << endl;
    }
};

// Functions work with appropriate interfaces
void feedBird(Bird& bird) {
    bird.eat();        // All birds can eat
    bird.makeSound();  // All birds can make sounds
}

void makeFlyableFly(Flyable& flyable) {
    flyable.fly();     // Only flyable objects
}

int main() {
    Duck duck;
    Eagle eagle;
    Penguin penguin;
    
    // All birds can be fed (LSP satisfied!)
    feedBird(duck);
    feedBird(eagle);
    feedBird(penguin);
    
    cout << "\nFlying demonstration:" << endl;
    makeFlyableFly(duck);
    makeFlyableFly(eagle);
    // makeFlyableFly(penguin);  // Compiler error - good!
    
    // Penguins have their own special abilities
    penguin.swim();
    
    return 0;
}</code></pre>
        </div>

        <div class="principle-summary">
            <h3>üìã LSP Benefits:</h3>
            <ul>
                <li><strong>Predictable Behavior:</strong> Child classes behave as expected from parent class</li>
                <li><strong>Reliable Polymorphism:</strong> You can safely use child objects through parent references</li>
                <li><strong>Better Design:</strong> Forces you to think about proper inheritance relationships</li>
                <li><strong>Fewer Bugs:</strong> Reduces unexpected runtime errors</li>
            </ul>
        </div>

        <!-- Interface Segregation Principle -->
        <h2 id="isp">4. üéØ Interface Segregation Principle (ISP)</h2>
        
        <div class="principle-header">
            <h3>"Clients should not be forced to depend upon interfaces they do not use"</h3>
        </div>

        <div class="simple-explanation">
            <h3>ü§î What does this mean?</h3>
            <p>Think of it like a <strong>restaurant menu</strong>: A vegetarian shouldn't be forced to see meat options. Similarly, a class shouldn't be forced to implement methods it doesn't need.</p>
            
            <p><strong>Simple Rule:</strong> Create small, focused interfaces instead of large, bloated ones!</p>
        </div>

        <div class="bad-example">
            <h3>‚ùå Bad Example - Violating ISP</h3>
            <pre><code>// Fat interface that forces classes to implement unused methods
class Worker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void takeSalary() = 0;  // Not all workers get salary!
    virtual void attendMeeting() = 0;  // Not all workers attend meetings!
    virtual ~Worker() = default;
};

// Human worker - implements all methods (makes sense)
class HumanWorker : public Worker {
public:
    void work() override {
        cout << "Human is working hard!" << endl;
    }
    
    void eat() override {
        cout << "Human is eating lunch." << endl;
    }
    
    void sleep() override {
        cout << "Human is sleeping." << endl;
    }
    
    void takeSalary() override {
        cout << "Human receives salary." << endl;
    }
    
    void attendMeeting() override {
        cout << "Human attends meeting." << endl;
    }
};

// Robot worker - forced to implement irrelevant methods!
class RobotWorker : public Worker {
public:
    void work() override {
        cout << "Robot is working efficiently!" << endl;
    }
    
    void eat() override {
        // Robots don't eat! But we're forced to implement this
        throw runtime_error("Robots don't eat!");
    }
    
    void sleep() override {
        // Robots don't sleep! But we're forced to implement this  
        throw runtime_error("Robots don't sleep!");
    }
    
    void takeSalary() override {
        // Robots don't get salary! But we're forced to implement this
        throw runtime_error("Robots don't get salary!");
    }
    
    void attendMeeting() override {
        // Most robots don't attend meetings! But we're forced to implement this
        throw runtime_error("Robots don't attend meetings!");
    }
};</code></pre>
        </div>

        <div class="good-example">
            <h3>‚úÖ Good Example - Following ISP</h3>
            <pre><code>// Small, focused interfaces
class Workable {
public:
    virtual void work() = 0;
    virtual ~Workable() = default;
};

class Eatable {
public:
    virtual void eat() = 0;
    virtual ~Eatable() = default;
};

class Sleepable {
public:
    virtual void sleep() = 0;
    virtual ~Sleepable() = default;
};

class Payable {
public:
    virtual void takeSalary() = 0;
    virtual ~Payable() = default;
};

class MeetingAttendee {
public:
    virtual void attendMeeting() = 0;
    virtual ~MeetingAttendee() = default;
};

// Human worker implements only relevant interfaces
class HumanWorker : public Workable, public Eatable, public Sleepable, 
                   public Payable, public MeetingAttendee {
public:
    void work() override {
        cout << "Human is working hard!" << endl;
    }
    
    void eat() override {
        cout << "Human is eating lunch." << endl;
    }
    
    void sleep() override {
        cout << "Human is sleeping." << endl;
    }
    
    void takeSalary() override {
        cout << "Human receives salary." << endl;
    }
    
    void attendMeeting() override {
        cout << "Human attends meeting." << endl;
    }
};

// Robot worker implements only what it actually needs
class RobotWorker : public Workable {
public:
    void work() override {
        cout << "Robot is working efficiently 24/7!" << endl;
    }
    
    void performMaintenance() {
        cout << "Robot is performing self-maintenance." << endl;
    }
};

// Advanced robot that can attend meetings
class AdvancedRobot : public Workable, public MeetingAttendee {
public:
    void work() override {
        cout << "Advanced robot is working with AI assistance!" << endl;
    }
    
    void attendMeeting() override {
        cout << "Advanced robot joins virtual meeting." << endl;
    }
};

// Usage example with different worker types
class WorkManager {
public:
    void manageWork(Workable& worker) {
        worker.work();
    }
    
    void organizeMeeting(vector<MeetingAttendee*>& attendees) {
        cout << "\nStarting meeting with " << attendees.size() << " attendees:" << endl;
        for (auto* attendee : attendees) {
            attendee->attendMeeting();
        }
    }
    
    void processPayroll(vector<Payable*>& employees) {
        cout << "\nProcessing payroll:" << endl;
        for (auto* employee : employees) {
            employee->takeSalary();
        }
    }
};

int main() {
    HumanWorker human;
    RobotWorker robot;
    AdvancedRobot advancedRobot;
    
    WorkManager manager;
    
    // All workers can work
    manager.manageWork(human);
    manager.manageWork(robot);
    manager.manageWork(advancedRobot);
    
    // Only meeting attendees can attend meetings
    vector<MeetingAttendee*> meetingAttendees = {&human, &advancedRobot};
    manager.organizeMeeting(meetingAttendees);
    
    // Only payable workers get salary
    vector<Payable*> employees = {&human};
    manager.processPayroll(employees);
    
    return 0;
}</code></pre>
        </div>

        <div class="principle-summary">
            <h3>üìã ISP Benefits:</h3>
            <ul>
                <li><strong>Focused Classes:</strong> Classes only implement what they actually need</li>
                <li><strong>Easier Testing:</strong> Smaller interfaces are easier to mock and test</li>
                <li><strong>Better Flexibility:</strong> Classes can implement multiple small interfaces as needed</li>
                <li><strong>Reduced Coupling:</strong> Changes to unused methods don't affect implementing classes</li>
            </ul>
        </div>

        <!-- Dependency Inversion Principle -->
        <h2 id="dip">5. üîÑ Dependency Inversion Principle (DIP)</h2>
        
        <div class="principle-header">
            <h3>"High-level modules should not depend on low-level modules. Both should depend on abstractions."</h3>
        </div>

        <div class="simple-explanation">
            <h3>ü§î What does this mean?</h3>
            <p>Think of it like a <strong>universal remote control</strong>: The remote (high-level) doesn't depend on specific TV brands (low-level). Instead, both follow the same standard (abstraction) - infrared signals.</p>
            
            <p><strong>Simple Rule:</strong> Depend on interfaces/abstractions, not concrete implementations!</p>
        </div>

        <div class="bad-example">
            <h3>‚ùå Bad Example - Violating DIP</h3>
            <pre><code>// Low-level modules (concrete implementations)
class MySQLDatabase {
public:
    void save(const string& data) {
        cout << "Saving to MySQL: " << data << endl;
        // MySQL specific implementation
    }
    
    string load(int id) {
        cout << "Loading from MySQL with ID: " << id << endl;
        return "MySQL data";
    }
};

class EmailService {
public:
    void sendEmail(const string& message) {
        cout << "Sending email: " << message << endl;
        // Email sending implementation
    }
};

// High-level module directly depends on low-level modules
class UserService {
private:
    MySQLDatabase database;    // Direct dependency on MySQL!
    EmailService emailService; // Direct dependency on EmailService!
    
public:
    void createUser(const string& userData) {
        // Business logic
        database.save(userData);  // Tightly coupled to MySQL
        emailService.sendEmail("Welcome!"); // Tightly coupled to EmailService
    }
    
    string getUser(int id) {
        return database.load(id); // Tightly coupled to MySQL
    }
};

// Problems:
// 1. Can't switch to PostgreSQL without changing UserService
// 2. Can't switch to SMS notifications without changing UserService  
// 3. Hard to test UserService in isolation
// 4. UserService breaks if database implementation changes</code></pre>
        </div>

        <div class="good-example">
            <h3>‚úÖ Good Example - Following DIP</h3>
            <pre><code>// Abstractions (interfaces)
class DatabaseInterface {
public:
    virtual void save(const string& data) = 0;
    virtual string load(int id) = 0;
    virtual ~DatabaseInterface() = default;
};

class NotificationInterface {
public:
    virtual void sendNotification(const string& message) = 0;
    virtual ~NotificationInterface() = default;
};

// Low-level modules implement abstractions
class MySQLDatabase : public DatabaseInterface {
public:
    void save(const string& data) override {
        cout << "Saving to MySQL: " << data << endl;
        // MySQL specific implementation
    }
    
    string load(int id) override {
        cout << "Loading from MySQL with ID: " << id << endl;
        return "MySQL data";
    }
};

class PostgreSQLDatabase : public DatabaseInterface {
public:
    void save(const string& data) override {
        cout << "Saving to PostgreSQL: " << data << endl;
        // PostgreSQL specific implementation
    }
    
    string load(int id) override {
        cout << "Loading from PostgreSQL with ID: " << id << endl;
        return "PostgreSQL data";
    }
};

class EmailNotification : public NotificationInterface {
public:
    void sendNotification(const string& message) override {
        cout << "Sending email: " << message << endl;
        // Email implementation
    }
};

class SMSNotification : public NotificationInterface {
public:
    void sendNotification(const string& message) override {
        cout << "Sending SMS: " << message << endl;
        // SMS implementation
    }
};

// High-level module depends on abstractions, not implementations
class UserService {
private:
    unique_ptr<DatabaseInterface> database;
    unique_ptr<NotificationInterface> notificationService;
    
public:
    // Dependency injection through constructor
    UserService(unique_ptr<DatabaseInterface> db, 
               unique_ptr<NotificationInterface> notification)
        : database(move(db)), notificationService(move(notification)) {}
    
    void createUser(const string& userData) {
        // Business logic remains the same
        database->save(userData);  // Works with any database!
        notificationService->sendNotification("Welcome new user!"); // Works with any notification!
    }
    
    string getUser(int id) {
        return database->load(id); // Works with any database!
    }
};

// Factory class to create different configurations
class ServiceFactory {
public:
    static unique_ptr<UserService> createMySQLEmailService() {
        auto db = make_unique<MySQLDatabase>();
        auto notification = make_unique<EmailNotification>();
        return make_unique<UserService>(move(db), move(notification));
    }
    
    static unique_ptr<UserService> createPostgreSQLSMSService() {
        auto db = make_unique<PostgreSQLDatabase>();
        auto notification = make_unique<SMSNotification>();
        return make_unique<UserService>(move(db), move(notification));
    }
};

// Mock implementations for testing
class MockDatabase : public DatabaseInterface {
public:
    void save(const string& data) override {
        cout << "Mock: Saving " << data << endl;
    }
    
    string load(int id) override {
        return "Mock data for ID " + to_string(id);
    }
};

int main() {
    cout << "=== Production Configuration 1 (MySQL + Email) ===" << endl;
    auto service1 = ServiceFactory::createMySQLEmailService();
    service1->createUser("John Doe");
    cout << "Retrieved: " << service1->getUser(1) << endl;
    
    cout << "\n=== Production Configuration 2 (PostgreSQL + SMS) ===" << endl;
    auto service2 = ServiceFactory::createPostgreSQLSMSService();
    service2->createUser("Jane Smith");
    cout << "Retrieved: " << service2->getUser(2) << endl;
    
    cout << "\n=== Testing Configuration (Mock) ===" << endl;
    auto mockDb = make_unique<MockDatabase>();
    auto mockNotification = make_unique<EmailNotification>();
    auto testService = make_unique<UserService>(move(mockDb), move(mockNotification));
    testService->createUser("Test User");
    
    return 0;
}</code></pre>
        </div>

        <div class="principle-summary">
            <h3>üìã DIP Benefits:</h3>
            <ul>
                <li><strong>Flexible Architecture:</strong> Easy to switch implementations without changing business logic</li>
                <li><strong>Easy Testing:</strong> Can inject mock objects for unit testing</li>
                <li><strong>Loose Coupling:</strong> High-level modules aren't affected by low-level changes</li>
                <li><strong>Better Maintainability:</strong> Changes in implementation don't ripple up to business logic</li>
            </ul>
        </div>

        <!-- Summary Section -->
        <h2>üéØ SOLID Principles Summary</h2>

        <div class="example">
            <h3>üìù Quick Reference Card</h3>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background-color: #f0f4ff;">
                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Principle</th>
                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Simple Rule</th>
                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Key Benefit</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>S</strong>RP</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">One class, one responsibility</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Easy to maintain and test</td>
                </tr>
                <tr style="background-color: #f9f9f9;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>O</strong>CP</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Extend, don't modify</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Safe to add new features</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>L</strong>SP</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Child can replace parent</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Reliable inheritance</td>
                </tr>
                <tr style="background-color: #f9f9f9;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>I</strong>SP</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Small, focused interfaces</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">No unused dependencies</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>D</strong>IP</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Depend on abstractions</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Flexible and testable</td>
                </tr>
            </table>
        </div>

        <div class="interview-tip">
            <h3>üíº Interview Tips</h3>
            <ul>
                <li><strong>Real Examples:</strong> Always provide concrete examples when explaining principles</li>
                <li><strong>Benefits:</strong> Explain WHY each principle matters, not just WHAT it is</li>
                <li><strong>Trade-offs:</strong> Acknowledge that over-engineering can also be a problem</li>
                <li><strong>Practical Application:</strong> Show how you've used these principles in real projects</li>
                <li><strong>Code Reviews:</strong> Mention how SOLID helps in code reviews and team collaboration</li>
            </ul>
        </div>

        <div class="simple-explanation">
            <h3>üöÄ Next Steps</h3>
            <p>Now that you understand SOLID principles:</p>
            <ol>
                <li><strong>Practice:</strong> Refactor some of your existing code using SOLID principles</li>
                <li><strong>Design Patterns:</strong> Learn how design patterns implement these principles</li>
                <li><strong>Code Reviews:</strong> Look for SOLID violations in code reviews</li>
                <li><strong>Architecture:</strong> Apply these principles at the architectural level</li>
                <li><strong>Testing:</strong> Notice how SOLID code is easier to test</li>
            </ol>
        </div>

        <footer>
            <p>üìö <strong>SOLID Principles Guide</strong> | Written for C++ Developers | Practice with real code examples!</p>
            <p>üí° Remember: These are guidelines, not rigid rules. Use them wisely based on your project's needs.</p>
        </footer>
    </div>
</body>
</html> 